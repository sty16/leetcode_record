# 面试准备计划 7.16~7.23

整体计划

https://cyc2018.github.io/CS-Notes/#/README

https://labuladong.gitbook.io/algo/

+ JAVASE语言基础 && 数据结构与算法  7.1~7.23

+ JVM  && 操作系统 && 多线程 && Linux && 计算机组成  7.24~8.15

+ JAVAEE Spring && Redis && 计算机网络  8.15~9.15

### 7.16 leetcode && 牛客网

leetcode 72 编辑距离 word1 转换成为word2的最少转换次数  动态规划：定义dp\[i][j]为word1[0:i]变换为word[0:j]的最小次数，状态转移考虑插入、删除、替换三种状态，注意初始状态dp\[0][0]表示从“”转换为“”的最少次数为0；

leetcode Pow(x, n); 快速幂算法  $n = i_02^0 + i_12^1 + \cdots + i_k2^k$，$x^n = x^{i_0^{2^0}} + x^{i_1^{2^1}} \cdots + x^{i_k^2{k}}$，因此采用位运算的方式。注意要定义为long的形式。

leetcode 3 无重复字符的最长子串 动态规划的方法 定义dp[i]为以i结尾的无重复子串的最长长度

leetcode 785 判断二分图  广度优先遍历，染色方法

 斐波那契递归时间复杂度 $O((\frac{1 + \sqrt{5}}{2})^n)$，空间复杂度为$O(n)$

牛客网 编程巅峰赛 第三场   

### 7.17 leetcode && 牛客网

牛客网巅峰赛第三场总结 

牛客网 找卧底 1到n有一个数字出现两次，找到出现两次的数字。先对1到n进行异或，然后再与数组进行异或。

牛客网 父子情深 采用无向图的邻接链表(List\<List\<Integer>>)的形式记录，在深度优先遍历时，利用每个节点有且仅有一个直接前驱的性质递归时传递父节点的信息。

牛客网 牛牛的Fib序列 $f[n] = \sum\limits_{i=1}^{m}a_if[x-i]$，等价于m阶线性方程，因为有效信息为m个，因此构造m维度向量$V[n] = (f[n],f[n-1] \cdots f[n-m+1])$,可推导出递推公式$V[n] = A^{n-1}V[1]$。

牛客网 位数求和 暴力枚举方法

牛客网 不可思议 

注意c++负数取模为负数，为保证结果为正，需要((x % mod) + mod) % mod 

树的定义 根节点只有直接后继，没有直接前驱。子树根节点**有且仅有一个直接前驱**，零个或多个直接后继。

图的表示方法，有向图、无向图，邻接矩阵与邻接表(链表) ，图的遍历 深度优先遍历(递归)，广度优先遍历(队列)

 ### 7.18 leetcode && 牛客网

牛客网 牛牛晾衣服 java优先级队列 不能随意修改其中元素，只适用于删除头部元素与插入元素。采用二分法，计算当前时间，除去自然干的衣服，剩余需烘干的衣服所需时间是否小于等于当前时间，从而进一步缩小检查范围。

在dfs时候，可能超过栈的最大深度，从而出现 java.lang.StackOverflowError错误，请检查是否存在数组越界等非法访问情况。在这种情况下尝试广度优先遍历。

leetcode 97 交错字符串 采用dfs的方式，并记录中间状态 record\[i][j]为s1前i位置与s2前j位置已经与s3的前i+j位匹配，后续是否能够继续匹配的状态。如果再次遍历到这个状态

牛客网 旋转跳跃 采用并查集，对可交换(连通)的位置进行分组， 并对不同分组的位置与对应元素进行升序排列，最终返回的为变换后最小的值。

```java
    public int find(int x){
        return x == father[x] ? x : (father[x] = find(father[x]));
    }
```

牛客网巅峰赛第四场

### 7.19 leetcode && 牛客网

leetcode 124 二叉树中的最大路径和  计算二叉树中的一个节点的最大贡献值，以该节点为起点，在其子树中找到路径和最大的最大路径，选用全局变量记录最大路径和，注意递归函数返回的是节点最大贡献值。

leetcode 129 求根到叶子节点数字之和，采用dfs，传递到达当前父节点的路径和，当到达叶子节点时，将路径和加入到全局变量。

leetcode 47 全排列 II   在选择每一行的元素时，如果出现重复则不能选择，重复的条件是 nums[i] == nums[i-1]  &&  isVisited[i-1]，表示上一个相同元素已经选过并退栈。

```
12345 ↙           依次选择的是1 2 3 5 4再选择一个数字后，需要对其进行标记
12345    ↘
12345     ↘
12345        ↘
12345      ↙
```

leetcode 39 组合总数 无重复元素数组和一个目标，同样将解空间类似成上图所示，当时为了保证找到的元素不重复，限制移动方向只能是向下或者向右。

leetcode 312 戳气球  有些类似于全排列问题，解空间为n!，普通递归求解时间复杂度为(O(n!))超时。采用分治法进行优化，分治后合并子问题考虑动态规划。令dp\[i][j]为扎破区间(i, j)获得的硬币数，假设最后扎破的为k其可以划分为dp\[i][k]与dp\[k][j]这两个子问题，从而推导出状态转移方程为：dp\[i][j] = $max_{k=i+1}^{j-1}$ val[i]×val[k]×val[j]+dp\[i][k]+dp\[k][j]。

leetcode  12 整数转罗马数字 采用贪心的方法，当一个罗马数字可以被多种形式表示的时候，从左到右选择尽可能大的符号表示。罗马数字总共有13个符号表示如下。

```
{1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1}
{"M","CM","D","CD","C","XC","L","XL","X","IX","V","IV","I"}
```

leetcode 89 格雷编码  镜像反射 G(n+1) = 0+G(n)  $\cup$  1+G(n).reverse();

leetcode 78 子集  类似于全排列，但是需要限定下次的位置只能从当前的下一个开始，及向右下方移动，同时每次深搜记录一次数据。

### 7.20 leetcode && 牛客网

leetcode  307 区域和检索(数组可修改) 线段树 每个节点保存一段线段，用于高效解决连续区间的动态查询问题。

线段树  在程序设计时， 按照满二叉树的思想写代码，完全二叉树性质叶子节点数 = 二度点数 + 1，构造2n长度的序列，下表从1开始，父节点与叶子节点的关系为 i 2i 2i+ 1

leetcode 167 两数之和II - 输入有序数组 双指针法。

leetcode 153 寻找旋转排序数组的最小值。 采用二分法，首先判断数组是否进行翻转。每次选择中点，如果中点与左右是严格升序的，则寻找左右两侧中左节点大于右节点的区间。 

leetcode 145 二叉树的后序遍历，递归 双栈 另一个栈记录当前状态是否可打印。

leetcode 22  括号生成 深度优先搜索dfs与回溯，选择2n个，全局变量记录左括号数与右括号数量。

leetcode 34  在排序数组查找元素的第一个和最后一个位置 二分法，然后找到第一个数值，然后找到两边的边界。

leetcode 300 最长上升子序列  注意子序列与子数组的区别 动态规划dp[i]表示以i为结尾的最大递增子序列长度，时间复杂度为O($n^2$)。转换状态tails[k]为当前长度为K的递增子序列末尾的最小值，采用二分法找到大于等于当前nums[i]的位置并更新。

leetcode 130 被围绕的区域 bfs过于复杂，明天尝试并查集实现。

### 7.21 leetcode && 牛客网

leetcode 95 不同的二叉搜索树II  递归返回List\<TreeNode>节点，利用搜索二叉树的性质，对区间做二划分。

剑指offer 12 矩阵中的路径  递归超时，如果找到答案后立刻返回，减少时间消耗。

leetcode 684 冗余连接 第一种方法，在增加一条联通信息时，先判断着两条点是否可达，采用dfs遍历。树中任何一点都可以看做是根节点。

“com.byte.dance.hotc”原地翻转为“hotc.dance.byte.com” 先reverse，然后对每个"."区间内再进行翻转。

leetcode 165 比较版本号  对字符按点分割成段，并采用双指针依次比较每个段,  保证可以跳到相应的位置。

```java
while(x < m - 1 && version1.charAt(x + 1) != '.') x++;
x++;
```

leetcode 88 合并两个有序数组 从尾部进行合并可以不用开辟额外的内存空间。

leetcode 100 相同的树 递归

leetcode 104 二叉树的最大深度 递归

leetcode 108 将有序数组转换为二叉搜索树 递归

DSU(disjoint set union) 并查集，一种用于不相交集合的数据结构。将n个不同的元素分成一组不相交的结合，三个基本操作：创建新的并查集，找到元素所属的集合，合并两个集合

新的并查集

```java
for(int i = 0; i < n; i++){
	father[i] = i;
}
```

查找元素所属集合 含路径压缩

```java
public int find(int x){
	return x == father[x] ? x : (father[x] = find(father[x]));
}
```

集合合并(按秩合并，按元素个数合并，直接合并)

```
public void union(int x, int y){
	father[find(y)] = find(x);
}
```

### 7.22 leetcode && 牛客网

剑指offer 11 旋转数组的最小数字  每次判断中间与右侧，并依此选定区间。二分法变种

```
while(i < j){
	int mid = i + (j - i) / 2;
	if(condition){
		j = mid; // i不等于j时 自然可以保证每次j变小。
	}else{
		i = mid + 1;
	}
}
```

剑指offer 29 顺时针打印矩阵  模拟方式 额外空间记录访问状态，定义四个方向，依次循环

leetcode 233 数字1的个数  按位分析的方式。

剑指offer 05 替换空格 

leetcode 509 斐波那契数 六种方法 递归、记忆化自顶向下，记忆化自底向上，矩阵快速幂，公式法。

剑指offer 67 把字符串转换成整数 1.采用long防止越界 2. 采用trim去除首尾空格 3. 在相加时，注意乘符号位，当发生溢出时，即使跳出循环返回。java不能自动向下转型double -> float。

leetcode 169 多数元素 

leetcode 468 验证IP地址 注意split("regex")与split("regex", -1)的区别，如果最后n为均为分隔符，加入-1仍然会继续分割。首先对字符串的位数进行判断，之后Character.isDigit()判断每一位是否数字，再用Integer.parseInt()解析。

使用正则表达式 

leetcode 355 设计推特 采用链表的方式记录每个用户发送的数据 合并k个排序列表。

### 7.23 leetcode && 牛客网

leetcode 23 合并k个排序链表 优先级队列 O(log(k)kn)

leetcode 98 复原IP地址 采用深度优先搜索的方式 寻找点可插入的位置 $C_{11}^{3}$

剑指offer 16 数值的整数次方 快速幂

剑指offer 58 I 翻转单词顺序 注意java split()，字符串比较实用equals

剑指offer 59 II 队列的最大值  采用双端队列来维护最大值，保证双端队列始终为非递增的序列，双端队列入队出队总次数在插入n个元素时小于2n ，均摊时间复杂度为O(1)。

剑指offer 04 二维数组的查找 每行与列均递增，这样矩阵的左下角与右上角元素具有特殊性，称为标志数。**右上角元素**：为所在**行最大**元素，所在**列最小**元素。因此每次比较可以消除一行或者一列，时间复杂度为O(m + n)



### 7.24 leetcode && 牛客网

leetcode 1025 除数博弈 采用一个状态来记录先手必胜或者必败的状态。

leetcode 239 滑动窗口的最大值 类似于O(1)记录最大值队列的方法 。



### 7.25 leetcode && 牛客网

leetcode 410 分割数组的最大值  将数组分割为m段，是动态规划常见问题

定义状态dp\[i][j]为前i个数分为j段 的子数组和最大值的最小值  i >= j 

leetcode 155 最小栈 

leetcode 101 对称二叉树  判断两棵子树根节点相同，两个节点的右子树与左子树镜像对称。两个子树对称。

剑指offer 18 删除链表节点。

剑指offer 20 表示数值的字符串 

剑指offer 21 调整数组顺序使奇数位于偶数前面，双指针原地调整顺序。

牛客网巅峰赛第六场 

单元最短路径 Dijkstra算法 https://www.zhihu.com/question/20630094/answer/758191548 

### 7.26 leetcode && 牛客网

牛客网 星球游戏 Dijkstra 优先队列实现。

leetcode 743 网络延迟时间 Dijkstra单源最短路径，注意边是单向还是双向的。

剑指offer 06 从尾到头打印链表 



### 7.27 leetcode && 牛客网

leetcode 392 判断子序列 双指针遍历、动态规划dp\[i][j]为字符串从位置i之后出现字符j的第一个位置

leetcode 954 二倍数对数组。

双层for循环寻找是否出现或者对应，都可以采用Map一次遍历来完成。遇到取绝对值的题目，看给出数据的范围，如果没有指定，需要转换成为long。

leetcode 898 子数组按位或操作 

连续子数组 前缀和 后缀和 复用信息

leetcode 404 左叶子之和 递归 注意式所有的左叶子节点。 

leetcode 787 K站中转内最便宜的航班 dijkstra可以记录第K次到达某点的最短的路径。采用map来记录第k次到达该点的路径长度

剑指offer 24 反转链表

深入了解lambda表达式。

http://zh.lucida.me/blog/java-8-lambdas-inside-out-library-features/

### 7.28 leetcode && 牛客网

股票 

leetcode 901 股票价格跨度  采用单调栈维护单调递减序列

leetcode 123 买卖股票的最佳时机II dp\[i]\[k][0]表示第i天第K次交易后 不拥有股票。

leetcode 329 矩阵中的最长递增路径

leetcode 505

leetcode 1334



leetcode 1348 推文计数

### 7.30 leetcode && 牛客网

leetcode 343 整数拆分，拆成K段最大值问题。

牛客网 巅峰赛 第7场  牛牛打怪兽 判断树叶子节点的方法。

注意如果要对java int[]类型数组进行降序排列，需要转换成为Integer型数组。

### 7.31 leetcode && 牛客网

面试题 08.03 魔术索引 如果是严格单调增，可以采用二分法，否则采用分治法。

牛牛的冰激凌 动态规划问题，时间与次数状态 f[i] = min(max(f[j] + t,  c[i]) + t) 、g[i] = min(g[j] + 1)  j = i-k...i-1，注意j == 0的特殊状态 其没有返回的t时间

数列求值  $a_i$ = b$a_{i-1}$+c$a_{i-2}$ 矩阵的快速幂 方法 mulvec mulself

