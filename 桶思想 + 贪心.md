### 桶思想 + 贪心

将序列重新排布，使得相同元素间隔至少为K, 在leetcode上总共有四道类似的题目

[leetcode 358 K距离间隔重排字符串](https://leetcode-cn.com/problems/rearrange-string-k-distance-apart/)

[leetcode 621 任务调度器](https://leetcode-cn.com/problems/task-scheduler/)

[leetcode 767 重构字符串](https://leetcode-cn.com/problems/reorganize-string/)

[leetcod 1054 距离相等的条形码](https://leetcode-cn.com/problems/distant-barcodes/)

首先统计各个字符出现的次数，并按照出现次数降序排序，例如字符串“aaaabbbbccddef”, 我们统计出各个字符出现的次数分别为{‘a' : 4, 'b' : 4, 'c' : 2, 'd' : 2, 'e' : 1, ’f' : 1}。题目要求，相邻字符串之间的距离至少为k，如果我们假设桶的大小为k，这样相同字符出现在不同桶的相同位置，那么其间距满足题目大于k的要求。

以上面的字符串为例，出现次数最多的字符为a出现了4次，那么我们定义桶的个数为n = 4(某元素出现的最大次数)，并将a填入到每一个桶的第一个位置。

![image-20201205174400345](C:\Users\sty\AppData\Roaming\Typora\typora-user-images\image-20201205174400345.png)

如果A之间的间隔至少为k， 那么前n - 1个桶的大小必须满足 $bucket[i].size >= k,    1\le i\le n-1$。

如果其他字母出现的次数等于桶的个数，那么需要将该元素填到每一个桶对应的位置，例如b出现了四次，那么将b填入桶中后桶的状态如下：

![image-20201205174443547](C:\Users\sty\AppData\Roaming\Typora\typora-user-images\image-20201205174443547.png)



如果元素出现的次数少于桶的个数，那么将元素按照顺序依次填入到前n-1个桶中来贪心的保证前n - 1个桶最大，从而相同字符之间的间隔最大。将c, d, e, f填入后，桶的状态如下：

![image-20201205175109028](C:\Users\sty\AppData\Roaming\Typora\typora-user-images\image-20201205175109028.png)

当所有字符填入完成后，需要判断前n - 1个桶的大小是否大于等于k, 如果小于k则无法进行重排

##### 代码

```cpp
class Solution {
public:
    string rearrangeString(string s, int k) {
        vector<int> cnt(26, 0);
        for (char c : s) {
            cnt[c - 'a']++;
        }
        vector<pair<int, char>> arr;
        for (int i = 0; i < 26; ++i) {
            if (cnt[i] > 0) arr.push_back({cnt[i], i + 'a'});
        }
        sort(arr.begin(), arr.end(), greater<pair<int, char>>());
        int maxi = arr[0].first;
        if (maxi == 1 || k == 0) return s;
        vector<vector<char>> bucket(maxi);
        string ans;
        int idx = 0;
        for (auto [c, v] : arr) {
            if (c == maxi) {
                for (int i = 0; i < maxi; ++i) {
                    bucket[i].push_back(v);
                }
            } else {
                for (int i = 0; i < c; ++i) {
                    bucket[idx].push_back(v);
                    idx = (idx + 1) % (maxi - 1);
                }
            }
        }
        for (int i = 0; i < maxi - 1; ++i) {
            if (bucket[i].size() < k) return "";
            else ans.insert(ans.end(), bucket[i].begin(), bucket[i].end());
        }
        ans.insert(ans.end(), bucket[maxi - 1].begin(), bucket[maxi - 1].end());
        return ans;
    }
};
```



##### 复杂度分析

+ 时间复杂度 ： $O(n + |\Sigma|log|\Sigma|)$， 其中n为字符串大小，$|\Sigma|$为字符串中字符种类的个数，因为均为小写字母，$|\Sigma|$小于等于26
+ 空间复杂度：$O(n + |\Sigma|)$

